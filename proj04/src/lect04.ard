\open Nat

-- Комментарии по предыдущей теме.

-- 1. Определение T, асбурдные паттерны.

\data Bool | true | false

\data Unit | unit

\data Empty

\func absurd' {A : \Type} (p : T false) : A

\data T (b : Bool) \with
  | true => tt

\func \infix 4 < (x y : Nat) : Bool
  | _, 0 => false
  | 0, suc y => true
  | suc x, suc y => x < y

-- n < 0

\data List (A : \Type) | nil | cons A (List A)

\func length {A : \Type} (xs : List A) : Nat
  | nil => 0
  | cons _ xs => length xs + 1

-- () -- это так называемый абсурдный паттерн.
-- Если у типа данных нет ни одного конструктора, то иногда соответствующую строчку можно опустить, но не всегда.
-- Если тайпчекер жалуется на то, что не все случаи покрыты, но у некоторого параметра нет ни одного конструктора, то вместо него можно написать ().
-- В этом случае правую часть можно (и нужно) опустить.

\func lookup {A : \Type} (xs : List A) (n : Nat) (p : T (n < length xs)) : A \elim xs, n, p
  | nil, 0, ()
  | nil, suc n, ()
  | cons x xs, 0, _ => x
  | cons x xs, suc n, p => lookup xs n p

-- 2. Определение Tree.

\data Tree (A : \Type) (n : Nat) \elim n
  | _ => Leaf
  | suc n => Branch A (Tree A n) (Tree A n)

-- 3. Строго положительные определения \data.

-- Все \data должны быть строго положительны.
-- Это означает, что рекурсивный вызов может встречаться только в определенных местах: справа от -> и в =.

{-
-- Если разрешить использовать произвольные типы данных, то легко написать функцию, которая не завершается.
-- Идея в том, что мы определеяем тип данных D, такой что D = (D -> D).
-- Такой тип данных соответствует типу нетипизированных лямбда-термов.
\data D | con (D -> D)

-- Определим терм omega = \lam d => d d
\func omega (d : D) : D
  | con f => f (con f)

-- Теперь определим терм Omega = omega omega, который не завершается.
\func Omega => omega (con omega)
-}

-- 4. Симметричность, транзитивность, принцип Лейбница, pmap через него.

-- Принцип Лейбница говорит, что если a и a' обладают одними и теми же свойствами, то они равны.
-- Его легко доказать.
\func Leibniz {A : \Type} {a a' : A}
  (f : \Pi (P : A -> \Type) -> \Sigma (P a -> P a') (P a' -> P a)) : a = a'
  => (f (\lam x => a = x)).1 idp

-- Обратный принцип Лейбница (который мы тоже будем называть принципом Лейбница) говорит, что если a = a', то они обладают одними и теми же свойствами, т.е. если верно B a, то верно B a'.
\func transport {A : \Type} (B : A -> \Type) {a a' : A} (p : a = a') (b : B a) : B a'
    => coe (\lam i => B (p @ i)) b right

-- Используя принцип Лейбница, легко доказать (почти) все свойства равенства.
-- Симметричность
\func sym {A : \Type} {a a' : A} (p : a = a') : a' = a
    => transport (\lam x => x = a) p idp

-- Транзитивность
\func trans {A : \Type} {a a' a'' : A} (p : a = a') (q : a' = a'') : a = a''
    => transport (\lam x => a = x) q p

-- Конгруэнтность
\func pmap' {A B : \Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a'
    => transport (\lam x => f a = f x) p idp

-- 5. Определение =.

-- В прелюдии определен тип I с двумя конструкторами left и right, но в отличии от обычных \data эти два конструктора равны.
-- Это означает, что для I нельзя использовать паттерн матчинг, так как иначе было бы легко вывести противоречие.
-- Так как left и right равны, то некоторые a : A и a' : A равны тогда и только тогда, когда существует функция f : I -> A, такая что f left == a и f right == a', где == -- это вычислительное равенство.
-- Тип a = {A} a' определен как тип функций I -> A, удовлетворяющих этому свойству.

-- Чтобы доказать, что a = a, можно взять константную функцию \lam _ => a : I -> A.
\func idp {A : \Type} {a : A} : a = a => path (\lam _ => a)

-- Если f : A -> B и g : I -> A, то их композиция дает нам pmap.
-- Действительно g доказывает, что g left = g right, а композиция f и g доказывает, что f (g left) = f (g right).
\func pmap {A B : \Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a'
    => path (\lam i => f (p @ i))

-- Функция @, определенная в прелюдии, -- это просто обратная функция к конструктору path.
-- path (f : I -> A) : f left = f right
-- @ (p : a = a') (i : I) : A
-- path f @ i == f i -- бета-эквивалентность
-- path (\lam i => p @ i) == p -- эта-эквивалентность.

-- pmap можно определять по разному, но если использовать определение, данное выше, то он будет обладать хорошими вычислительными свойствами.
-- Например, pmap id = id и pmap (f . g) = pmap f . pmap g, где (.) -- это композиция.
-- Если определить pmap по другому, то эти равенства тоже будут верны, но не вычислительно, то есть их нельзя будет доказать просто по рефлексивности.
\func pmap-idp {A : \Type} {a a' : A} (p : a = a') : pmap {A} (\lam x => x) p = p
    => idp

-- 6. Функциональная экстенсиональность.

-- Функциональная экстенсиональность говорит, что если две функции f и g равны на всех аргументах, то они равны.
-- Ее легко доказать, используя наше определение равенства.
\func funExt {A : \Type} (B : A -> \Type) {f g : \Pi (a : A) -> B a}
    (p : \Pi (a : A) -> f a = g a) : f = g
    => path (\lam i => \lam a => p a @ i)

-- В большинстве других языков с зависимыми типами ее доказать нельзя.
-- Ее можно добавить просто как аксиому, то есть функцию без реализации, но аксиомы обычно не любят добавлять, так как это портит вычислительные свойства языка.

-- Например, если мы добавим аксиому исключенного третьего lem, то легко написать константу foo : Nat, которая не будет вычисляться ни в какое конкретное число.
-- \func lem : \Pi (X : \Type) -> Either X (X -> Empty)
-- \func foo : Nat => \case lem Nat \with { | Left => 0 | Right => 1 }

-- 7. left = right

-- Чтобы доказать, что в I действительно только один элемент, нам нужно использовать функцию coe, определенную в прелюдии.
-- О ней можно думать как об элиминаторе для I.
-- Она говорит, что для определения функции над I достаточно определить ее для left.
-- Для сравнения элиминатор для Bool говорит, что для определения функции над Bool достаточно определить ее для true и false.

-- Используя coe, легко доказать, что любой i : I равен left.
\func left=i (i : I) : left = i
  -- | left => idp
  => coe (\lam i => left = i) idp i

-- В частности left = right.
\func left=right : left = right => left=i right

-- 8. coe и transport.

-- Функция coe тесно связана с transport.
-- Мы определили transport через coe.

-- \func transport {A : \Type} (B : A -> \Type) {a a' : A} (p : a = a') (b : B a) : B a'
--     => coe (\lam i => B (p @ i)) b right
-- Пусть B' = \lam i => B (p @ i).
-- Тогда
-- B' : I -> \Type
-- B' left == B a
-- B' right == B a'

-- В ДЗ нужно будет показать, что через transport определеяется частный случай coe.
