\open Nat

-- 1. Вселенные, полиморфизм по уровням.

-- Тип \Type0 содержит все типы, которые не упоминают \Type0.
-- Тип \Type1 содержит все типы, которые могут упоминать \Type0, но не \Type1.
-- И так далее. Тип \Type n содержит все типы, которые упоминают только \Type i для i < n.
-- Тип \Type i называется вселенной, а число i называется уровнем вселенной.
\func tt : \Type2 => \Type0 -> \Type1

-- Когда мы определяем полиморфную функцию, такую как id, мы хотим, чтобы тип A мог лежать в любой вселенной.
-- Поэтому все функции (и остальные определения) полиморфны по уровню вселенной, в которой они лежат.
\func id (A : \Type) (a : A) => a

-- У каждого определения есть неявный параметр-уровень, к которому можно обратиться, написав \lp.
-- Например, функция id, определенная выше, эквивалентна такому определению:
\func id_ (A : \Type \lp) (a : A) => a

-- Когда мы пишем \Type без указания уровня, тайпчекер сам выводит минимальный подходящий уровень.
\func type : \Type => \Type

-- Например, в примере выше у \Type, который написан в теле функции, будет выведен уровень \lp.
-- У \Type, который написан в типе, уровень \lp не может быть, так как не верно, что \Type \lp : \Type \lp, поэтому он будет на 1 выше, то есть \suc \lp.
\func type_ : \Type (\suc \lp) => \Type \lp

-- На уровнях есть небольшой набор операций:
-- * Любое натуральное число является уровнем
-- * \suc l
-- * \max l1 l2
-- То есть любой уровень является либо константой, либо эквивалентен уровню вида \max (\lp + c) c', где c и c' -- константы, а \lp + c -- это уровень вида \suc (\suc ... (\suc \lp) ... ).
-- Уровень пи-типов и других конструкций над типами -- это максимум из уровней типов, входящих в эту конструкцию.
\func test0 : \Type (\max (\suc (\suc \lp)) 4) => \Type (\max \lp 3) -> \Type (\suc \lp)

-- Еще несколько примеров:
\func test1 => id Nat 0
\func test2 => id \Type0 Nat
\func test3 => id (\Type0 -> \Type1) (\lam X => X)
\func test4 => id _ id
\func test4' => id (\Pi (A : \Type) -> A -> A) id

-- При обращении к определению можно явно указать его уровень, то есть чему будет равен параметр \lp:
\func test5 => id (\suc \lp) (\Type \lp) Nat
-- Либо так:
\func test5' => id (\levels (\suc \lp) _) (\Type \lp) Nat
-- Второй вариант синтаксиса полезен когда уровень является константой:
\func test6 => id (\levels 2 _) \Type1 \Type0
-- Если при обращению к определению уровень не указан явно, он будет выведен автоматически как и в случае с \Type.
-- В большинстве случаев нет необходимости указывать уровень явно.

-- Параметры \data не влияют на его уровень.
\data Magma' (A : \Type)
  | con (A -> A -> A)

\func test7 : \Type \lp => Magma' \lp Nat

-- Уровень класса зависит от того, какие поля реализованы.
\class Magma (A : \Type)
  | \infixl 6 ** : A -> A -> A

-- Например, уровень Magma \lp -- это \Type (\suc \lp), так как в определении Magma \lp появляется вселенная \Type \lp.
\func test8 : \Type (\suc \lp) => Magma \lp

-- Но уровень Magma \lp Nat -- это просто \Type \lp, так как в нереализованных полях Magma Nat не встречаются вселенные.
\func test9 : \Type \lp => Magma \lp Nat

\class Functor (F : \Type -> \Type)
  | fmap {A B : \Type} : (A -> B) -> F A -> F B

\data Maybe (A : \Type) | nothing | just A

-- Уровень Functor \lp будет \Type (\suc \lp) даже если поле F реализовано, так как в поле fmap тоже появляется \Type \lp.
\func test10 : \Type (\suc \lp) => Functor \lp Maybe

-- 2. Предикаты.

-- Есть несколько способов определять предикаты над некоторым типом A:
-- * Выразить из через уже существующие (например равенство) и различные логические связки. Например, предикат isEven можно выразить как \lam n => \Sigma (k : Nat) (n = 2 * k).
-- * Рекурсивно. Этот способ работает только если A -- тип данных.
-- * Индуктивно.

\data Unit | unit

\data Empty

-- Определение <= через равенство.
\func LessOrEq''' (n m : Nat) => \Sigma (k : Nat) (k + n = m)

-- Рекурсивное определение предиката <=
\func lessOrEq (n m : Nat) : \Type
  | 0, _ => Unit
  | suc _, 0 => Empty
  | suc n, suc m => lessOrEq n m

-- Первое индуктивное определение <=
\data LessOrEq (n m : Nat) \with
  | 0, m => z<=n
  | suc n, suc m => s<=s (LessOrEq n m)

\func test11 : LessOrEq 0 100 => z<=n
\func test12 : LessOrEq 3 67 => s<=s (s<=s (s<=s z<=n))
-- \func test10 : LessOrEq 1 0 => ....

-- Второе индуктивное определение -- это модификация первого, где вместо паттерн матчинга в \data мы используем равенство.
\data LessOrEq' (n m : Nat)
  | z<=n' (n = 0)
  | s<=s' {n' m' : Nat} (n = suc n') (m = suc m') (LessOrEq' n' m')

-- Один и тот же предикат можно определить индуктивно различными способами.
-- Когда мы хотим задать предикат индуктивно, нам нужно просто написать набор правил, которые верны для данного предиката и при этом пораждают его.
-- Например, в LessOrEq у нас два правила: 0 <= m для любого m и, если n <= m, то suc n <= suc m. Любое неравенство можно получить из этих двух правил.

-- Но это не единственный набор правил, который пораждает <=.
-- Например, мы можем взять следующий набор: n <= n для всех n и, если n <= m, то n <= suc m.
-- Этот набор реализован в LessOrEq''.

-- Третье индуктивное определение <=
\data LessOrEq'' (n m : Nat) \elim m
  | suc m => <=-step (LessOrEq'' n m)
  | m => <=-refl (n = m)
