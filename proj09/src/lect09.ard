\open Nat

-- 1. Предикат ``домен функции''

-- Вспомогательные функции

\data Bool | true | false

\func not (b : Bool) : Bool
  | true => false
  | false => true

\func if {A : \Type} (b : Bool) (t e : A) : A \elim b
  | true => t
  | false => e

\func \infix 4 < (n m : Nat) : Bool
  | _, 0 => false
  | 0, suc _ => true
  | suc n, suc m => n < m

\func \infixl 6 - (n m : Nat) : Nat
  | 0, _ => 0
  | suc n, 0 => suc n
  | suc n, suc m => n - m

\data T (b : Bool) \with
  | true => tt

\func idp {A : \Type} {a : A} => path (\lam _ => a)

\func transport {A : \Type} (B : A -> \Type) {a a' : A} (p : a = a') (b : B a) => coe (\lam i => B (p @ i)) b right

-- Очевидное определение div, которое может не завершаться
-- \func div (x y : Nat) => if (x < y) 0 (suc (div (x - y) y))

-- По любой рекурсивной функции можно построить предикат на ее аргументах, который будет эквивалентен утверждению, что эта функция определена на этих аргументах.
-- Каждому ветвлению соответствует конструктор, в который передается доказательство того, что выражение, на котором мы ветвимся, равно значению в соответствующей ветке.
-- Кроме того, для каждого рекурсивного вызова функции в некоторой ветке мы добавляем в соответствующий конструктор рекурсивный вызов предиката от тех же аргументов.
\data divDom (n k : Nat)
  | lt (T (n < k))
  | geq (T (not (n < k))) (divDom (n - k) k)

-- Теперь мы можем передать в функцию доказательство того, что ее аргументы лежат в ее домене, и определить ее рекурсией по этому доказательству.
\func div {x y : Nat} (d : divDom x y) : Nat \elim d
  | lt _ => 0
  | geq _ d => suc (div d)

-- Еще немного вспомогательных конструкций.
\data ModView (m n : Nat)
  | quot-rem (q r : Nat) (t : T (r < m)) (p : r + m * q = n)

\func mod-view (m n : Nat) (t : T (0 < m)) : ModView m n => {?}

\func <lem (r k m : Nat) : T (not (r + (m + k) < k))
  | 0, 0, 0 => tt
  | suc _, 0, 0 => tt
  | _, 0, suc _ => tt
  | r, suc k, m => <lem r k m

\func -lem (r k m : Nat) : r + m = r + (m + k) - k \elim r, k, m
  | 0, 0, 0 => idp
  | suc _, 0, 0 => idp
  | r, 0, suc _ => idp
  | r, suc k, m => -lem r k m

\func <0lem (n k : Nat) (p : T (n < k)) : T (0 < k) \elim n, k
  | 0, 0 => p
  | suc n, 0 => p
  | _, suc _ => tt

-- Нам нужно доказать, что предикат divDom n k действительно эквивалентен домену функции div, то есть T (k < 0).

-- В одну сторону это легко сделать.
\func fromDivDom {n k : Nat} (d : divDom n k) : T (0 < k)
  | lt t => <0lem _ _ t
  | geq t d => fromDivDom d

-- В другую сделать напрямую это сложно, поэтому мы воспользуемся ModView.
\func toDivDom {n k : Nat} (t : T (0 < k)) : divDom n k => \case mod-view k n t \with {
  | quot-rem q r s p => helper n k q r s p
} \where {
  \func helper (n k q r : Nat) (s : T (r < k)) (p : r + k * q = n) : divDom n k \elim q
    | 0 => lt (transport (\lam x => T (x < k)) p s)
    | suc q => geq (transport (\lam x => T (not (x < k))) p (<lem _ _ _))
                   (helper (n - k) k q r s (transport (\lam x => r + k * q = x - k) p (-lem _ _ _)))
}

-- 2. Принципы индукции.

-- Для любого индуктивного типа данных можно определить рекурсор.
-- Рекурсор -- это функция определенного вида.
-- Первым аргументом она принимает тип E, а последним элемент нашего типа данных, и возвращает E.
-- Остальные аргументы зависят от типа данных.
-- Для каждого конструктора мы добавляем по аргументу.
-- Все эти дополнительные аргументы имеют тип вида ... -> E.
-- Вместо ... мы пишем параметры конструктора, где для каждого рекурсивного вызова данных мы добавляем еще один параметр типа E.

-- Пример: рекурсор для натуральных чисел.
\func Nat-rec {E : \Type} (z : E) (s : Nat -> E -> E) (n : Nat) : E \elim n
  | zero => z
  | suc n => s n (Nat-rec z s n)

-- Рекурсор для Bool -- это просто if с переставленными аргументами.
\func Bool-rec {A : \Type} (t e : A) (b : Bool) : A \elim b
  | true => t
  | false => e

\data D
  | con1 Nat
  | con2 D D
  | con3 (Nat -> D)

-- Еще один пример: рекурсор для D.
\func D-rec {E : \Type} (c1 : Nat -> E) (c2 : D -> E -> D -> E -> E) (c3 : (Nat -> D) -> (Nat -> E) -> E) (d : D) : E \elim d
  | con1 n => c1 n
  | con2 d1 d2 => c2 d1 (D-rec c1 c2 c3 d1) d2 (D-rec c1 c2 c3 d2)
  | con3 f => c3 f (\lam n => D-rec c1 c2 c3 (f n))

-- Если у типа данных есть параметры, они просто добавляются в качестве первых параметров функции и везде передаются без изменений.
\data Maybe (A : \Type) | nothing | just A

\func Maybe-rec {A : \Type} {E : \Type} (n : E) (j : A -> E) (m : Maybe A) : E \elim m
  | nothing => n
  | just a => j a

-- Любую независимую структурно рекурсивную функцию можно записать через рекурсор.
{-
-- Произвольная структурно рекурсивная функция имеет следующий вид:
\func f (n : Nat) : E -- это произвольный тип
  | zero => z -- это произвольное выражение
  | suc n => s -- это произвольное выражение, в котором могут встречаться n и f n.

-- Такую функцию можно записать через Nat-rec следующим образом:
\func f' => Nat-rec E z (\lam n r => s[r / f n]) -- то есть в s мы заменяем все вхождения f n на r.
-}

-- Элиминатор для типа данных -- это обобщение рекурсора, которое позволяет определять и зависимые функции.
-- Теперь первый параметр E -- это не просто тип, а тип, параметризованный нашим типом данных.
-- Элиминатор возвращает E n, где n -- это последний параметр элиминатора.
-- В остальных параметрах мы применяем E к соответствующим конструкторам.

-- Пример: элиминатор для Nat.
\func Nat-elim (E : Nat -> \Type) (z : E zero) (s : \Pi (n : Nat) -> E n -> E (suc n)) (n : Nat) : E n \elim n
  | zero => z
  | suc n => s n (Nat-elim E z s n)

-- Пример: элиминатор для Bool.
\func Bool-elim (E : Bool -> \Type) (t : E true) (e : E false) (b : Bool) : E b \elim b
  | true => t
  | false => e

-- Пример: элиминатор для Maybe.
\func Maybe-elim {A : \Type} (E : Maybe A -> \Type) (n : E nothing) (j : \Pi (a : A) -> E (just a)) (m : Maybe A) : E m \elim m
  | nothing => n
  | just a => j a

-- Элиминатор для рекурсивного типа данных -- это просто принцип индукции для него.
-- Мы можем определять свои принципы индукции, которые удобнее использовать, чем стандартные.
-- Например, для натуральных чисел мы можем определить принцип индукции, который позволяет использовать индукционную гипотезу для любого числа, меньшего данного, а не только для числа, меньшего на 1.
\func Nat-ind (E : Nat -> \Type)
  (r : \Pi (n : Nat) -> (\Pi (k : Nat) -> T (k < n) -> E k) -> E n)
  (n : Nat) : E n => {?}

-- 3. Индукция-рекурсия

-- Рекурсия-рекурсия -- это принцип, позволяющий определять взаимно рекурсивные функции.
-- Пример: функции isEven и isOdd.
\func isEven (n : Nat) : Bool
  | 0 => true
  | suc n => isOdd n

\func isOdd (n : Nat) : Bool
  | 0 => false
  | suc n => isEven n

-- Индукция-индукция -- это принцип, позволяющий определять взаимно рекурсивные типы данных.
-- Когда мы определяем взаимно рекурсивный тип данных, нужно явно указывать его тип.
-- Пример: типы IsEven и IsOdd.
\data IsEven (n : Nat) : \Type \with
  | 0 => zero-isEven
  | suc n => suc-isEven (IsOdd n)

\data IsOdd (n : Nat) : \Type \with
  | suc n => suc-isOdd (IsEven n)

-- Индукция-рекурсия -- это принцип, позволяющий определять тип данных, взаимно рекурсивный с функцией.
-- Мы увидим пример такого определения ниже.

-- 4. Вселенные.

-- \Type0 -- это тип, элементы которого -- это малые типы.
-- Такой тип называется вселенной.
-- Мы можем определить свою вселенную, состоящую только из определенного набора типов.

\data List (A : \Type) | nil | cons A (List A)

\data Type
  | nat
  | list Type
  | arr Type Type

-- Мы должны еще определить функцию, которая переводит элементы Type в настоящие типы.
\func El (t : Type) : \Type0 \elim t
  | nat => Nat
  | list t => List (El t)
  | arr t1 t2 => El t1 -> El t2

-- Если мы хотим определить вселенную, в которой у нас есть заисимые типы, то такое определение должно быть индуктивно-рекурсивным.
\data Type' : \Type0
  | nat'
  | list' Type'
  | pi' (a : Type') (El' a -> Type')

\func El' (t : Type') : \Type0 \elim t
  | nat' => Nat
  | list' t => List (El' t)
  | pi' t1 t2 => \Pi (a : El' t1) -> El' (t2 a)
