\import lect07
\open Nat

-- 1. Реализуйте любой алгоритм сортировки, используя with для паттерн матчинга на результате сравнения элементов списка.

-- 2. Определите filter через if, а не через with.
--    Докажите для этой версии filter лемму filter-lem.

\func filter' {A : \Type} (p : A -> Bool) (xs : List A) : List A => {?}

\func filter-lem {A : \Type} (p : A -> Bool) (xs : List A) : length (filter' p xs) <= length xs => {?}

-- 3. Докажите, что если равенство элементов A разрешимо, то и равенство элементов List A тоже разрешимо.

\instance ListEq {A : \Type} (dec : Eq A) : Eq (List A)
  | decideEq => {?}

-- 4. Докажите, что предикат isEven разрешим.

\func isEven (n : Nat) => \Sigma (k : Nat) (n = 2 * k)

\func isEven-dec : DecPred isEven => {?}

-- 5. Докажите, что если равенство элементов A разрешимо, то любой список элементов A либо пуст, либо состоит из повторений одного элемента, либо в A существует два различных элемента.

\func repeat {A : \Type} (n : Nat) (a : A) : List A \elim n
  | 0 => nil
  | suc n => cons a (repeat n a)

\data Result (A : \Type) (xs : List A)
  | empty (xs = nil)
  | repeated (n : Nat) (a : A) (p : xs = repeat n a)
  | A-is-not-trivial (a a' : A) (p : a = a' -> Empty)

\func lemma {A : \Type} (xs : List A) {dec : DecEq A} : Result A xs => {?}

-- 6. Определите view, представляющий число в виде частного и остатка от деления его на произвольное (неотрицательное) число m.
--    Реализуйте функцию деления.

\data ModView (m n : Nat)
  | quot-rem (q r : Nat) (t : T (r < m)) (p : n = q * m + r)

\func mod-view (m n : Nat) (t : T (0 < m)) : ModView m n => {?}

\func div (n m : Nat) (t : T (0 < m)) : Nat => {?}

-- 7. Докажите, что функции FromBoolToDec и FromDecToBool взаимно обратны.

\func bdb {A : \Type} (p : A -> Bool) : FromDecToBool (FromBoolToDec p) = p => {?}

-- Мы не можем доказать, что FromBoolToDec (FromDecToBool P) = P, но мы можем доказать более слабое утверждение: эти предикаты логически эквивалентны.
-- Для этого введем эквивалентность предикатов.

\func \infix 4 <-> {A : \Type} (P Q : A -> \Type) => \Pi (x : A) -> \Sigma (P x -> Q x) (Q x -> P x)

\func dbd {A : \Type} (P : \Sigma (P : A -> \Type) (DecPred P)) : (FromBoolToDec (FromDecToBool P)).1 <-> P.1 => {?}
